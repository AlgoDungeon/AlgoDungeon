function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { mergeRefs } from "@chakra-ui/utils";
import * as React from "react";
import { getArrowStyles, getBoxShadow, toTransformOrigin } from "./popper.utils";
import { usePopper as useBasePopper } from "./react-popper";
export function usePopper(props) {
  var _popperJS$state$place, _popperJS$state;

  if (props === void 0) {
    props = {};
  }

  var {
    placement = "bottom",
    preventOverflow = true,
    fixed = false,
    flip = true,
    arrowSize = 8,
    arrowShadowColor,
    gutter = 8,
    arrowPadding = 4,
    offset: offsetProp,
    matchWidth,
    modifiers = []
  } = props;
  var [referenceNode, setReferenceNode] = React.useState(null);
  var [popperNode, setPopperNode] = React.useState(null);
  var [arrowNode, setArrowNode] = React.useState(null);
  /**
   * recommended via popper docs
   * @see https://popper.js.org/react-popper/v2/faq/#why-i-get-render-loop-whenever-i-put-a-function-inside-the-popper-configuration
   */

  var customModifiers = React.useMemo(() => {
    var offset = offsetProp != null ? offsetProp : [0, gutter];
    return [// @see https://popper.js.org/docs/v2/modifiers/offset/
    {
      name: "offset",
      options: {
        offset: offset != null ? offset : [0, gutter]
      },
      phase: "main"
    }, // @see https://popper.js.org/docs/v2/modifiers/prevent-overflow/
    {
      name: "preventOverflow",
      enabled: !!preventOverflow,
      phase: "main"
    }, // @see https://popper.js.org/docs/v2/modifiers/arrow/
    {
      name: "arrow",
      enabled: !!arrowNode,
      options: {
        element: arrowNode,
        padding: arrowPadding
      },
      phase: "main"
    }, // @see https://popper.js.org/docs/v2/modifiers/flip/
    {
      name: "flip",
      enabled: flip,
      options: {
        padding: 8
      },
      phase: "main"
    }, {
      name: "matchWidth",
      enabled: !!matchWidth,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: (_ref2) => {
        var {
          state
        } = _ref2;
        state.styles.popper.width = state.rects.reference.width + "px";
      },
      effect: (_ref3) => {
        var {
          state
        } = _ref3;
        return () => {
          var reference = state.elements.reference;
          state.elements.popper.style.width = reference.offsetWidth + "px";
        };
      }
    }, {
      name: "applyArrowHide",
      enabled: true,
      phase: "write",

      fn(_ref4) {
        var {
          state
        } = _ref4;
        var {
          arrow
        } = state.elements;

        if (arrow) {
          var _state$modifiersData$;

          if (((_state$modifiersData$ = state.modifiersData.arrow) == null ? void 0 : _state$modifiersData$.centerOffset) !== 0) {
            arrow.setAttribute("data-hide", "");
          } else {
            arrow.removeAttribute("data-hide");
          }
        }
      }

    }];
  }, [arrowNode, arrowPadding, flip, preventOverflow, offsetProp, gutter, matchWidth]);
  var popperJS = useBasePopper(referenceNode, popperNode, {
    placement,
    strategy: fixed ? "fixed" : "absolute",
    modifiers: customModifiers.concat(modifiers)
  });
  /**
   * Ensure the popper will be correctly positioned with an extra update
   */

  React.useEffect(() => {
    popperJS.forceUpdate == null ? void 0 : popperJS.forceUpdate();
  });
  var finalPlacement = (_popperJS$state$place = (_popperJS$state = popperJS.state) == null ? void 0 : _popperJS$state.placement) != null ? _popperJS$state$place : placement;
  var arrowStyles = getArrowStyles({
    placement: finalPlacement,
    popperArrowStyles: popperJS.styles.arrow,
    arrowSize
  });
  var getReferenceProps = React.useCallback(function (props, _ref) {
    if (props === void 0) {
      props = {};
    }

    if (_ref === void 0) {
      _ref = null;
    }

    return _extends({}, props, {
      ref: mergeRefs(setReferenceNode, _ref)
    });
  }, []);
  var getPopperProps = React.useCallback(function (props, _ref) {
    var _popperJS$styles;

    if (props === void 0) {
      props = {};
    }

    if (_ref === void 0) {
      _ref = null;
    }

    return _extends({}, props, popperJS.attributes.popper, {
      ref: mergeRefs(setPopperNode, _ref),
      style: _extends({}, props.style, (_popperJS$styles = popperJS.styles) == null ? void 0 : _popperJS$styles.popper)
    });
  }, [popperJS.attributes, popperJS.styles]);
  var getArrowWrapperProps = React.useCallback(function (props, _ref) {
    if (props === void 0) {
      props = {};
    }

    if (_ref === void 0) {
      _ref = null;
    }

    return _extends({}, props, popperJS.attributes.arrow, {
      ref: mergeRefs(setArrowNode, _ref),
      style: _extends({}, props.style, arrowStyles)
    });
  }, [popperJS.attributes, arrowStyles]);
  var getArrowProps = React.useCallback(function (props, _ref) {
    if (props === void 0) {
      props = {};
    }

    if (_ref === void 0) {
      _ref = null;
    }

    return _extends({}, props, {
      ref: _ref,
      style: _extends({
        boxShadow: getBoxShadow(finalPlacement, arrowShadowColor)
      }, props.style, {
        position: "absolute",
        zIndex: -1,
        width: "100%",
        height: "100%",
        transform: "rotate(45deg)"
      })
    });
  }, [finalPlacement, arrowShadowColor]);
  return {
    transformOrigin: toTransformOrigin(finalPlacement),
    getReferenceProps,
    getPopperProps,
    getArrowWrapperProps,
    getArrowProps,
    state: popperJS.state,
    forceUpdate: popperJS.forceUpdate,
    update: popperJS.update,
    placement: finalPlacement
  };
}
//# sourceMappingURL=use-popper.js.map